<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>3.2 — Repeated Games</title>
    <meta charset="utf-8" />
    <meta name="author" content="Ryan Safner  Assistant Professor of Economics   safner@hood.edu   ryansafner/gameF21   gameF21.classes.ryansafner.com " />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/hygge.css" rel="stylesheet" />
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <script src="libs/freezeframe/freezeframe.min.js"></script>
    <script src="libs/xaringanExtra-freezeframe/freezeframe-init.js"></script>
    <script id="xaringanExtra-freezeframe-options" type="application/json">{"selector":"img[src$=\"gif\"]","trigger":"click","overlay":false,"responsive":true,"warnings":true}</script>
    <script src="https://use.fontawesome.com/5235085b15.js"></script>
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# 3.2 — Repeated Games
## ECON 316 • Game Theory • Fall 2021
### Ryan Safner<br> Assistant Professor of Economics <br> <a href="mailto:safner@hood.edu"><i class="fa fa-paper-plane fa-fw"></i>safner@hood.edu</a> <br> <a href="https://github.com/ryansafner/gameF21"><i class="fa fa-github fa-fw"></i>ryansafner/gameF21</a><br> <a href="https://gameF21.classes.ryansafner.com"> <i class="fa fa-globe fa-fw"></i>gameF21.classes.ryansafner.com</a><br>

---




class: inverse

# Outline

### [When Pure Strategies Won't Work](#3)
### [MSNE in Constant Sum Games](#16)
### [Coordination Games: PSNE and MSNE](#67)

---

class: inverse, center, middle

# Prisoners' Dilemma, Reprise

---

# Prisoners' Dilemma, Reprise

.center[
&lt;iframe width="980" height="550" src="https://www.youtube.com/embed/K4GAQtGtd_0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;
]

---

# Prisoners' Dilemma, Reprise

.pull-left[
- Not technically a Prisoners' Dilemma!
  - Game affected by Joker's threat to blow both of them up at midnight if nobody acts
  
- Both players have a *weakly*-dominant strategy to Detonate

- What is/are the Nash equilibrium/equilibria?

]

.pull-right[
.center[
![](../images/batman_pd.png)
]
]

---

# Prisoners' Dilemma, Reprise

.pull-left[
.smallest[
- A true prisoners' dilemma: 
`$$a&gt;b&gt;c&gt;d$$`

- Each player's preferences: 
    - 1&lt;sup&gt;st&lt;/sup&gt; best: you Defect, they Coop. ("temptation payoff")
    - 2&lt;sup&gt;nd&lt;/sup&gt; best: you both Coop.
    - 3&lt;sup&gt;rd&lt;/sup&gt; best: you both Defect
    - 4&lt;sup&gt;th&lt;/sup&gt; best: you Coop., they Defect ("sucker's payoff")

- Nash equilibrium: (.red[Defect], .blue[Defect])
  - (.red[Coop.], .blue[Coop.]) an unstable Pareto improvement

]
]

.pull-right[
.center[
![](../images/pdpayoffs4.png)
]
]

---

# Prisoners' Dilemma: How to Sustain Cooperation?

.pull-left[
- We'll stick with these specific payoffs for this lesson

- .hi-purple[How can we sustain cooperation in Prisoners' Dilemma?]

]

.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

class: inverse, center, middle

# Repeated Games

---

# Repeated Games: Finite and Infinite

.pull-left[
.smallest[
- Analysis of games can change when players encounter each other *more than once*

- .hi[Repeated games]: the same players play the same game multiple times, two types:

- Players know the *history* of the game with each other

- .hi-purple[Finitely-repeated game]: has a known final round

- .hi-purple[Infinitely-repeated game]: has no (or an unknown) final round

]
]
.pull-right[
.center[
![](../images/infinitelyrepeated.JPG)
]
]

---

class: inverse, center, middle

# Finitely-Repeated Games

---

# Finitely-Repeated Prisoners' Dilemma

.pull-left[
.smaller[
- Suppose a prisoners' dilemma is played for 2 rounds

- Apply .hi-purple[backwards induction:]
    - What should each player do in the final round?
]
]
.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

# Finitely-Repeated Prisoners' Dilemma

.pull-left[
.smaller[
- Suppose a prisoners' dilemma is played for 2 rounds

- Apply .hi-purple[backwards induction:]
    - What should each player do in the final round?
    - Play dominant strategy: **Defect**
    - Knowing each player will Defect in round 2/2, what should they do in round 1?
]
]
.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

# Finitely-Repeated Prisoners' Dilemma

.pull-left[
.smaller[
- Suppose a prisoners' dilemma is played for 2 rounds

- Apply .hi-purple[backwards induction:]
    - What should each player do in the final round?
    - Play dominant strategy: **Defect**
    - Knowing each player will Defect in round 2/2, what should they do in round 1?
        - No benefit to playing Cooperate
        - No threat punish Defection!
]
]

.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

# Finitely-Repeated Prisoners' Dilemma

.pull-left[
.smaller[
- Suppose a prisoners' dilemma is played for 2 rounds

- Apply .hi-purple[backwards induction:]

- Both **Defect** in round 1 (and round 2)

- No value in cooperation over time!
]
]

.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

# Finitely-Repeated Prisoners' Dilemma

.pull-left[
- For any game with a unique PSNE in a one-shot game, as long as there is a known, finite end, Nash equilibrium is the same

]

.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

# Finitely-Repeated Prisoners' Dilemma

.pull-left[
- In experimental settings, we tend to see people cooperate in early rounds, but close to the final round (if not the actual final round), defect on each other

]

.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

class: inverse, center, middle

# Infinitely-Repeated Games

---

# Infinitely-Repeated Games

.pull-left[
.smaller[
- Finitely-repeated games are interesting, but rare
  - How often do we know for certain when a game/relationship we are in will end? 

- Some predictions for finitely-repeated games don't hold up well in reality
  - Ultimatum game, prisoners' dilemma

- We often play games or are in relationships that are .hi[indefinitely repeated] (have no *known* end), we call them .hi[infinitely-repeated games]

]]

.pull-right[
.center[
![](../images/infinitelyrepeated.JPG)
]
]

---

# Infinitely-Repeated Games

.pull-left[

- There are two nearly identical interpretations of infinitely repeated games:
  1. Players play *forever*, but discount (payoffs in) the future by a constant factor
  2. Each round the game might end with some constant probability
]

.pull-right[
.center[
![](../images/infinitelyrepeated.JPG)
]
]

---

# First Intepretation: Discounting the Future

.pull-left[

- Since we are dealing with payoffs in the future, we have to consider players' .hi[time preferences]

- Easiest to consider with monetary payoffs and the .hi[time value of money] that underlies finance

`$$PV=\frac{FV}{(1+r)^t}$$`

`$$FV = PV(1+r)^t$$`

]

.pull-right[
.center[
![](../images/timeandmoney.jpg)
]
]

---

# Present vs. Future Goods

.pull-left[

- .hi-green[Example]: what is the present value of getting $1,000 one year from now at 5% interest?

`$$\begin{align*}
PV &amp;= \frac{FV}{(1+r)^n}\\
PV &amp;= \frac{1000}{(1+0.05)^1}\\
PV &amp;= \frac{1000}{1.05}\\
PV &amp;= \$952.38\\ 
\end{align*}$$`

]

.pull-right[
&lt;img src="3.2-slides_files/figure-html/unnamed-chunk-1-1.png" width="504" style="display: block; margin: auto;" /&gt;
]

---

# Present vs. Future Goods

.pull-left[

- .hi-green[Example]: what is the *future* value of $1,000 lent for one year at 5% interest?

`$$\begin{align*}
FV &amp;= PV(1+r)^n\\
FV &amp;= 1000(1+0.05)^1\\
FV &amp;= 1000(1.05)\\
FV &amp;= \$1050\\
\end{align*}$$`

]

.pull-right[
&lt;img src="3.2-slides_files/figure-html/unnamed-chunk-2-1.png" width="504" style="display: block; margin: auto;" /&gt;
]

---

# Discounting the Future

.pull-left[
- Suppose a player values $1 now as being equivalent to some amount with interest `\(1(1+r)\)` *one period later*
  - i.e. $1 with an r% interest rate over that period

- The .hi-purple[“discount factor”] is `\(\delta=\frac{1}{1+r}\)`, the ratio that future value must be multiplied to equal present value

]

.pull-right[
.center[
![](../images/timeandmoney.jpg)
]
]

---

# Discounting the Future

.pull-left[
$$\$1 \text{ now} = \delta \, \$1 \text{ later}$$

.smallest[
- If `\(\delta\)` is low `\((r\)` is high)
  - Players regard future money as worth much less than present money, **very impatient**
  - .hi-green[Example]: `\(\delta = 0.20\)`, future money is worth 20% of present money

- If `\(\delta\)` is high `\((r\)` is low)
  - Players regard future money almost the same as present money, **more patient**
  - .hi-green[Example]: `\(\delta = 0.80\)`, future money is worth 80% of present money
]
]

.pull-right[
.center[
![](../images/timeandmoney.jpg)
]
]

---

# Discounting the Future

.smallest[
.content-box-green[
.hi-green[Example]: Suppose you are indifferent between having $1 today and $1.10 next period
]
]

--

.smallest[
`$$\begin{align*}
\$1 \text{ today} &amp;= \delta \$1.10 \text{ next period}\\
\frac{\$1}{\$1.10} &amp; = \delta\\
0.91 &amp;\approx \delta\\
\end{align*}$$`

]

--

.smallest[
- There is an implied interest rate of `\(r=0.10\)`

- $1 at 10% interest yields $1.10 next period

`$$\begin{align*}
\delta &amp;= \frac{1}{1+r}\\
\delta &amp;= \frac{1}{1.10}\ \approx 0.91\\
\end{align*}$$`

]

---

# Discounting the Future

- Now consider an infinitely repeated game

--
  - If a player receives payoff `\(p\)` in every future round, the **present value** of this infinite payoff stream is
    
`$$p(\delta+\delta^2+\delta^3+ \cdots)$$`
  - This is due to compounding interest over time
--

- This infinite sum converges to:

`$$\sum_{t=1}^\infty=\frac{p}{1-\delta}$$`
- Thus, the present discounted value of receiving `\(p\)` in every future round is `\(\left(\frac{p}{1-\delta}\right)\)`

---

# Prisoners' Dilemma, Infinitely Repeated

.pull-left[
- With these payoffs, the value of both **cooperating** forever is `\(\left(\frac{3}{1-\delta}\right)\)`
- Value of both **defecting** forever is `\(\left(\frac{2}{1-\delta}\right)\)`

]

.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

# Alternatively: Game Continues Probabilistically

.pull-left[
- **Alternate interpretation**: game continues with some (commonly known among the players) probability `\(\theta\)` each round

- Assume this probability is independent between rounds (i.e. one round continuing has no influence on the probability of the *next* round continuing, etc)

]

.pull-right[
.center[
![](../images/infinitelyrepeated.JPG)
]
]

---

# Alternatively: Game Continues Probabilistically

.pull-left[
.smallest[

- Then the probability the game is played `\(T\)` rounds from now is `\(\theta^T\)`

- A payoff of `\(p\)` in every future round has a present value of
`$$p(\theta+\theta^2+\theta^3+\cdots)= \left(\frac{p}{1-\theta}\right)$$`

- This is similar to discounting of future payoffs; equivalent if `\(\theta=\delta\)`
]
]

.pull-right[
.center[
![](../images/infinitelyrepeated.JPG)
]
]

---
# Strategies in Infinitely Repeated Games

.pull-left[

.smallest[
- Recall, a .hi[strategy] is a complete plan of action that describes how you will react under all possible circumstances (i.e. moves by other players)
    - i.e. "if other player plays `\(x\)`, I'll play `\(a\)`, if they play `\(y\)`, I'll play `\(b\)`, if, ..., etc"
    - think about it as a(n infinitely-branching) game tree, .hi-turquoise[“what will I do at each node where it is my turn?”]
    
- For an infinitely-repeated game, .hi-turquoise[an infinite number of possible strategies exist!]

- We will examine a specific set of .hi[contingent] or .hi[trigger strategies]
]
]

.pull-right[
.center[
![](../images/thinker2.jpg)

![](../images/iftt.png)
]
]

---

# Trigger Strategies

.pull-left[
.smallest[
- Consider one (the most important) trigger strategy for an infinitely-repeated prisoners' dilemma, the .hi[“Grim Trigger” strategy]:
  - **On round 1**: Cooperate
  - **Every future round:** so long as the history of play has been (Coop, Coop) in every round, play Cooperate. Otherwise, play Defect *forever.*
    
- “**Grim**” trigger strategy leaves no room for forgiveness: one deviation triggers *infinite punishment*, like the sword of Damocles

]
]

.pull-right[
.center[
![:scale 50%](../images/swordofdamocles.jpg)
]
]

---

# Payoffs in Grim Trigger Strategy

.pull-left[
- If you are playing the **Grim Trigger strategy**, consider your opponent's incentives:
    - If you both *Cooperate* forever, you receive an infinite payoff stream of 3 per round

`$$3+3\delta+3\delta^2+3\delta^3+\cdots+3\delta^{\infty}=\frac{3}{1-\delta}$$`

]

.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

# Payoffs in Grim Trigger Strategy

.pull-left[
- This strategy is a Nash equilibrium as long there's no incentive to deviate: 

.smallest[
`$$\begin{align*}
\text{Payoff to cooperation} &amp; &gt; \text{Payoff to one-time defection}\\
\frac{3}{1-\delta} &amp; &gt;  4+\frac{2\delta}{1-\delta}\\
\delta &amp; &gt; 0.5\\
\end{align*}$$`

]

- If `\\(\delta &gt; 0.5\\)`, then player will cooperate and not defect

]

.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

# Payoffs in Grim Trigger Strategy

.pull-left[
- `\(\delta &gt; 0.5\)` is sufficient to sustain cooperation under the grim trigger strategy
    - This is the most extreme strategy with the strongest threat

]

.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

# Payoffs in Grim Trigger Strategy

.pull-left[
- Two interpretations of `\(\delta &gt; 0.5\)` as a sufficient condition for cooperation:

1.  `\(\delta\)` as .hi-purple[sufficiently high discount rate]
    - Players are patient enough and care about the future (reputation, etc), will not defect
2.  `\(\delta\)` as .hi-purple[sufficiently high probability of repeat interaction]
    - Players expect to encounter each other again and play future games together

]

.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---
# Other Trigger Strategies

.pull-left[
.smallest[
- "Grim Trigger" strategy is, well, grim: a single defection causes infinite punishment with no hope of redemption
  - *Very useful* in game theory for understanding the “worst case scenario” or the *bare minimum* needed to sustain cooperation!
  - Empirically, most people aren't playing this strategy in life
  - Social cooperation hangs on by a thread: what if the other player makes a *mistake*? Or *you* mistakenly think they Defected?
- There are “nicer” trigger strategies
]
]

.pull-right[
.center[
![:scale 50%](../images/swordofdamocles.jpg)
]
]

---

# "Nicer" Strategies

.pull-left[
- Consider a .hi["Forgiving Trigger" strategy]:
    - On round 1: Cooperate
    - Every future round: so long as the history of play has been (Coop, Coop) in every round, play Cooperate. Otherwise, play Defect for 3 rounds
        - Punishment, but lasts for 3 rounds, then reverts to Cooperation
]

.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

# "Nicer" Strategies

.pull-left[
- Consider the .hi["Tit for Tat" strategy]:
    - On round 1: Cooperate
    - Every future round: Play the strategy that the other player played last round
        - Example: if they Cooperated, play Cooperate; if they Defected, play Defect
]

.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

# "Nicer" Strategies

.pull-left[
- Consider the .hi["Tit for 2 Tats" strategy]:
    - On round 1: Cooperate
    - Every future round: Cooperate, unless the other player has played Defect twice, then play Defect
]

.pull-right[
.center[
![](../images/pdpayoffs3.png)
]
]

---

# *The Evolution of Cooperation*

.left-column[
.center[
![:scale 80%](../images/axelrod2.jpg)

.smallest[
Robert Axelrod

1943—
]
]
]

.right-column[
.smallest[
- Research in explaining the **evolution of cooperation**
- Use prisoners' dilemma to describe human societies and evolutionary biology of animal behaviors
- Hosted a series of famous tournaments for experts to submit a strategy to play in an infinitely&lt;sup&gt;.magenta[1]&lt;/sup&gt; repeated prisoners' dilemma 

]

.quitesmall[
&gt; “The contestants ranged from a 10-year-old computer hobbyist to professors of computer science, economics, psychology, mathematics, sociology, political science, and evolutionary biology.”

]

.smallest[
- *The Evolution of Cooperation* (1984)
- Among the most cited works in all of political science 
]

.source[&lt;sup&gt;.magenta[1]&lt;/sup&gt; Each round had a 0.00346 probability of ending the game, ensuring on average 200 rounds of play

Axelrod, Robert, 1984, *The Evolutioon of Cooperation]

]

---

# *The Evolution of Cooperation*

.left-column[
.center[
![:scale 80%](../images/axelrod2.jpg)

.smallest[
Robert Axelrod

1943—
]
]
]

.right-column[
.smallest[
- Axelrod's discussion of successful strategies based on four properties:
  1. **Niceness**: cooperate, never be the first to defect
  2. **Be Provocable**: don't be suckered by being too nice, return defection with defection
  3. **Don't be envious**: focus on maximizing your own score, rather than ensuring your score is higher than your "partner's"
  4. **Don't be too clever**: clarity is essential for others to cooperate with you

- The winning strategy was, famously, **TIT FOR TAT**, submitted by Anatol Rapoport

]
.source[Axelrod, Robert, 1984, *The Evolutioon of Cooperation]
]

---

class: inverse, center, middle

# The Folk Theorem

---

# The Folk Theorem

.pull-left[
- Consider the **average payoff** to each player each round, depending on the strategies chosen
    - e.g. if both Cooperate forever, average payoff is (3,3) — both earn 3 every round

]

.pull-right[
&lt;img src="3.2-slides_files/figure-html/unnamed-chunk-3-1.png" width="504" style="display: block; margin: auto;" /&gt;

]

---

# The Folk Theorem

.pull-left[
- Consider the **average payoff** to each player each round, depending on the strategies chosen
    - e.g. if both Cooperate forever, average payoff is (3,3) — both earn 3 every round
- Consider the .red[set of feasible average payoff]
    - e.g. no way to produce average payoff of (6,6)
    - average payoff of (2.5, 2.5) is possible (players alternate between C and D each round)

]

.pull-right[
&lt;img src="3.2-slides_files/figure-html/unnamed-chunk-4-1.png" width="504" style="display: block; margin: auto;" /&gt;

]

---

# The Folk Theorem

.pull-left[

- .hi[Folk theorem]: any .hi-purple[individually rational] and feasible average payoff can be sustained with sufficiently high `\(\delta\)` (or `\(\theta)\)`

- An average payoff is .hi-purple[individually rational] if it is at least as good as the one-shot Nash equilibrium (Defect, Defect), i.e. (2,2) outcome

]

.pull-right[
&lt;img src="3.2-slides_files/figure-html/unnamed-chunk-5-1.png" width="504" style="display: block; margin: auto;" /&gt;

]

---

# Folk Theorem: Simply Put

.pull-left[
.smallest[
- .hi[Folk theorem (simplified)]: Many strategies can sustain long-run cooperation if:
    - Each player can observe history
    - The value of future interactions must be sufficiently important to players
        - sufficiently high discount rate `\(\delta\)`
        - sufficiently high probability of game continuing `\(\theta\)`
- If this is true, *many* strategies can sustain long-run cooperation
    - Any in the teal set in the diagram before
    - *Grim trigger* is simply the bare minimum/worst case scenario (and, importantly, easiest to model!)
]
]

.pull-right[
.center[
![](../images/backstab.jpg)
]
]

---

# Assessing the Folk Theorem

.pull-left[
.smallest[
- **The Good**: cooperation is possible, rational, and efficient!
  - Any improvement above (D,D) is a Pareto improvement for all players
    
- **The Bad**: lack of predictive power
  - Anything goes! Almost *any* outcome can be a sustainable equilibrium
  - This is why game theorists use the grim trigger strategy results as the *bare minimum* sufficient strategy for cooperation
    
- As temptation payoff increases relative to Nash equilibrium, need higher `\(\delta\)` or `\(\theta\)` to sustain cooperation
]
]

.pull-right[
.center[
![](../images/backstab.jpg)
]
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script src="https://platform.twitter.com/widgets.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"slideNumberFormat": "<div class=\"progress-bar-container\">\n  <div class=\"progress-bar\" style=\"width: calc(%current% / %total% * 100%);\">\n  </div>\n</div>\n"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
