<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>1.3 — Sequential Games</title>
    <meta charset="utf-8" />
    <meta name="author" content="Ryan Safner  Assistant Professor of Economics   safner@hood.edu   ryansafner/gameF21   gameF21.classes.ryansafner.com " />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/hygge.css" rel="stylesheet" />
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <script src="libs/freezeframe/freezeframe.min.js"></script>
    <script src="libs/xaringanExtra-freezeframe/freezeframe-init.js"></script>
    <script id="xaringanExtra-freezeframe-options" type="application/json">{"selector":"img[src$=\"gif\"]","trigger":"click","overlay":false,"responsive":true,"warnings":true}</script>
    <script src="https://use.fontawesome.com/5235085b15.js"></script>
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# 1.3 — Sequential Games
## ECON 316 • Game Theory • Fall 2021
### Ryan Safner<br> Assistant Professor of Economics <br> <a href="mailto:safner@hood.edu"><i class="fa fa-paper-plane fa-fw"></i>safner@hood.edu</a> <br> <a href="https://github.com/ryansafner/gameF21"><i class="fa fa-github fa-fw"></i>ryansafner/gameF21</a><br> <a href="https://gameF21.classes.ryansafner.com"> <i class="fa fa-globe fa-fw"></i>gameF21.classes.ryansafner.com</a><br>

---




class: inverse

# Outline

### [Games in Extensive Form](#3)
### [Mover Advantages](#)
### [How Reasonable is Rollback Thinking?](#)

---

# The Century Mark Game

.pull-left[
.bg-washed-blue.b--dark-blue.ba.bw2.br3.shadow-5.ph4.mt5[
.hi-blue[Rules]: Two (teams of) players alternating turns

- The count starts at 0
  1. Team 1 adds a number 1-10 to the tally
  2. Team 2 adds a number 1-10 to the tally
- The first team to bring the tally to 100 wins
]
]

.pull-right[
.center[
![](../images/100.png)
]
]

---

# Sequential Games with Perfect Information

.pull-left[

- Strict order of play

- Perfect information
  - No **external uncertainty**: nature/probability does not interfere between choices `\(\rightarrow\)` outcomes
  - No **strategic uncertainty**: each player observes the history of other players’ moves

- Can be represented in .hi[extensive form], i.e. a .hi[game tree]
]

.pull-right[
.center[
![](../images/firstmove.jpg)
]
]

---

class: inverse, center, middle

# Games in Extensive Form

---

# Games in Extensive Form

.pull-left[
- .hi-green[Example]: “trust” game

- .hi-red[Principal] starts with $100. If they .red[invest], with .hi-blue[Agent], it doubles to $200

- .hi-blue[Agent] then decides whether to .blue[share] or .blue[keep] it 
]

.pull-right[
.center[
![](../images/pa_game.png)
]
]

---

# Games in Extensive Form

.pull-left[
- .hi-green[Example]: “trust” game

1. .hi-red[Principal] (.red[Player 1]) moves first.

2. .hi-blue[Agent] (.blue[Player 2]) moves second (but only if .hi-red[Principal] has played .red[Invest]).

- The game ends.
]

.pull-right[
.center[
![](../images/pa_game.png)
]
]

---

# Games in Extensive Form

.pull-left[
- Designing a game tree:

- .hi-purple[Decision nodes]: decision point for each player
  - Solid nodes, I've labeled and color-coded by player (.red[P.1], .blue[A.1])

- .hi-purple[Terminal nodes]: outcome of game, with payoff for each player
  - Hollow nodes, no further choices
]

.pull-right[
.center[
![](../images/pa_game.png)
]
]

---

# Games in Extensive Form: Outcomes

.pull-left[
- Three possible outcomes:

1. (.red[Don't]): .red[100], .blue[0]
2. (.red[Invest], .blue[Keep]): .red[0], .blue[200] 
3. (.red[Invest], .blue[Share]): .red[150], .blue[50]

]

.pull-right[
.center[
![](../images/pa_game.png)
]
]

---

# Strategies

.pull-left[
- .hi[(“Pure”) strategy]: a player’s **complete** plan of action for every possible contingency
  - i.e. what player will choose at **every possible decision node**, even if it’s never reached

- Think of a strategy like an .hi-turquoise[algorithm]:

&gt; If we reach node 1, then I will play X; if we reach node 2, then I will play Y; if...
]

.pull-right[
.center[
![](../images/pa_game.png)
]
]

---

# Trust Game: Strategies

.pull-left[

- .hi-red[Principal] has 2 possible strategies:
  1. .red[Don't] at .red[P.1]
  2. .red[Invest] at .red[P.1]

- .hi-blue[Agent] has 2 possible strategies:
  1. .blue[Keep] at .blue[A.1]
  2. .blue[Share] at .blue[A.1]

- Note .hi-blue[Agent]'s strategy only comes into play if .hi-red[Principal] plays .red[Invest] and the game reaches node .blue[A.1] 

]

.pull-right[
.center[
![](../images/pa_game.png)
]
]

---

# Solving the Game: Backward Induction

.pull-left[
.smallest[
- Solve a sequential game by .hi[“backward induction”] or .hi[“rollback”]

- To determine the outcome of the game, start with the *last-mover* (i.e. decision nodes just before terminal nodes) and work to the beginning

- A process of considering .hi-purple[“sequential rationality”]:

&gt; “If I play X, my opponent will respond with Y; given their response, do I really want to play X?”

- What is that mover's best choice to maximize their payoff?
]

]

.pull-right[
.center[
![](../images/pa_game.png)
]
]

---

# Solving the Game: Backward Induction

.pull-left[

- We start at .blue[A.1] where .hi-blue[Agent] can:
  - .blue[Keep] to yield outcome (.red[0], .blue[200])
  - .blue[Share] to yield outcome (.red[150], .blue[50])

]

.pull-right[
.center[
![](../images/pa_game.png)
]
]

---

# Solving the Game: Backward Induction

.pull-left[

- We start at .blue[A.1] where .hi-blue[Agent] can:
  - .blue[Keep] to yield outcome (.red[0], .blue[200])
  - .blue[Share] to yield outcome (.red[150], .blue[50])

- .hi-blue[Agent] only considers their own payoff
  - (.red[Invest], .blue[Keep]) `\(\succ\)` (.red[Invest], .blue[Share])
  - .blue[200] `\(\succ\)` .blue[50]
]

.pull-right[
.center[
![](../images/pa_game.png)
]
]

---

# Solving the Game: Backward Induction

.pull-left[

- .hi-blue[Agent] will .blue[Keep] if the game reaches node .blue[A.1]

- Recognizing this, what will .hi-red[Principal] do?
]

.pull-right[
.center[
![](../images/pa_game_2.png)
]
]

---

# Solving the Game: Backward Induction

.pull-left[

- Work our way up to .red[P.1] where .hi-red[Principal] can:
  - .red[Don't] to yield outcome (.red[100], .blue[0])
  - .red[Invest], knowing .hi-blue[Agent] will .blue[Keep], to yield outcome (.red[0], .blue[200])

- .hi-red[Principal] only considers their own payoff
  - (.red[Don't]) `\(\succ\)` (.red[Invest], .blue[Keep])
  - .red[100] `\(\succ\)` .red[0]

]

.pull-right[
.center[
![](../images/pa_game_2.png)
]
]

---

# Solving the Game: Backward Induction

.pull-left[

- .hi.purple[Equilibrium]: (.red[Don't], .blue[Keep])
  - Defined by the strategy played by each player

]

.pull-right[
.center[
![](../images/pa_game_rollback.png)
]
]

---

# Solving the Game: Pruning the Tree

.pull-left[

- As we work backwards, we can .hi-turquoise[prune] the branches of the game tree
  - Highlight branches that players **will** choose
  - Cross out branches that players will **not** choose

- .hi-purple[Equilibrium path of play] is highlighted from the root to one terminal node
  - (.red[Don't])
  - All other paths are not taken

]

.pull-right[
.center[
![](../images/pa_game_rollback.png)
]
]

---

# Another Example: Senate Race

.pull-left[
- Incumbent .hi-brown[Senator Brown] runs for reelection

- Challenger is .hi-green[Congresswoman Green]

- .hi-brown[Brown] moves first, must decide early-on to .brown[Run Ads] or .brown[No Ads]

- .hi-green[Green] moves second, must decide to .green[Enter] or .green[Stay Out]

]

.pull-right[
.center[
![](../images/pol_game.png)
]
]

---

# Another Example: Senate Race

.pull-left[
- Payoff considerations:
  - Ads are costly, .hi-brown[Brown] would prefer to not run ads
  - .hi-green[Green] will fare better if .hi-brown[Brown] does not run ads

- Use 1,2,3,4 for simple rankings
]

.pull-right[
.center[
![](../images/pol_game.png)
]
]

---

# Senate Race Game: Strategies

.pull-left[

- .hi-brown[Brown] has 2 strategies:
  1. .brown[Ads] at .brown[B.1]
  2. .brown[None] at .brown[B.1]

]

.pull-right[
.center[
![](../images/pol_game.png)
]
]

---

# Senate Race Game: Strategies

.pull-left[

- .hi-green[Green] has 4 strategies:

- Two decision nodes, two strategies at each node, hence `\(2^2=4\)`
  1. .green[Enter] at .green[G.1]; .green[Enter] at .green[G.2]
  2. .green[Enter] at .green[G.1]; .green[Stay Out] at .green[G.2]
  3. .green[Stay Out] at .green[G.1]; .green[Enter] at .green[G.2]
  4. .green[Stay Out] at .green[G.1]; .green[Stay Out] at .green[G.2]

]

.pull-right[
.center[
![](../images/pol_game.png)
]
]

---

# Senate Race Game: Strategies

.pull-left[

- Remember, think about a strategy like an algorithm
  1. If .brown[Ads] then .green[Enter]; if .brown[None] then .green[Enter] (always Enter)
  2. If .brown[Ads] then .green[Enter]; if .brown[None] then .green[Stay Out]
  3. If .brown[Ads] then .green[Stay Out]; if .brown[None] then .green[Enter]
  4. If .brown[Ads] then .green[Stay Out]; if .brown[Stay Out] then .green[Stay Out] (always Stay Out)

]

.pull-right[
.center[
![](../images/pol_game.png)
]
]

---

# Senate Race Game: Solution

.pull-left[

- To apply backward induction, begin with the last-mover

1. What will .hi-green[Green] choose...
  - If .hi-brown[Brown] were to run .brown[Ads]?
  - If .hi-brown[Brown] were to run .brown[None]?

]

.pull-right[
.center[
![](../images/pol_game.png)
]
]

---

# Senate Race Game: Solution

.pull-left[

- To apply backward induction, begin with the last-mover

1. What will .hi-green[Green] choose...
  - If .brown[Ads] then .green[Stay Out] (at B.1)
  - If .brown[None] then .green[Enter] (at B.2)

2. Given this, what will .hi-brown[Brown] choose?
]

.pull-right[
.center[
![](../images/pol_game_2.png)
]
]

---

# Senate Race Game: Solution

.pull-left[

- To apply backward induction, begin with the last-mover

1. What will .hi-green[Green] choose...
  - If .brown[Ads] then .green[Stay Out] (at B.1)
  - If .brown[None] then .green[Enter] (at B.2)

2. Given this, what will .hi-brown[Brown] choose?
  - (.brown[Ads], .green[Stay Out]) `\(\succ\)` (.brown[None], .green[Enter])
  - (.brown[3]) `\(\succ\)` (.brown[2])
]

.pull-right[
.center[
![](../images/pol_game_2.png)
]
]

---

# Senate Race Game: Solution

.pull-left[

- .purple[Equilibrium:] (.brown[Ads], .green[(Stay Out, Enter)])

- Notation:
  - .hi-brown[Brown's] strategy shows his decision at .brown[B.1] only
  - .hi-green[Green]'s strategy shows her decisions at .green[(G.1,G.2)]
  
]

.pull-right[
.center[
![](../images/pol_game_rollback.png)
]
]

---

class: inverse, center, middle

# Mover Advantages

---

# Mover Advantage: Senate Race Game

.pull-left[

- Is there an .hi[order advantage] to the Senate Race game?

- We saw what happens when .hi-brown[Brown] moves first

- Change the rules so that .hi-green[Green] moves first and see what changes
  - Be careful how you write the payoffs!
]

--

.pull-right[
.center[
![](../images/pol_game_reverse.png)
]
]

---

# Mover Advantage: Senate Race Game

.pull-left[

- .hi-green[Green] has 2 strategies:
  1. .green[Enter] at .green[G.1]
  2. .green[Stay Out] at .green[G.1]

]


.pull-right[
.center[
![](../images/pol_game_reverse.png)
]
]

---

# Mover Advantage: Senate Race Game

.pull-left[

- .hi-green[Green] has 2 strategies:
  1. .green[Enter] at .green[G.1]
  2. .green[Stay Out] at .green[G.1]

- .hi-brown[Brown] has 4 strategies:
  1. .brown[Ads] at .brown[B.1]; .brown[Ads] at .brown[B.2]
  2. .brown[Ads] at .brown[B.1]; .brown[None] at .brown[B.2]
  3. .brown[None] at .brown[B.1]; .brown[Ads] at .brown[B.2]
  4. .brown[None] at .brown[B.1]; .brown[None] at .brown[B.2]

]

.pull-right[
.center[
![](../images/pol_game_reverse.png)
]
]

---

# Mover Advantage: Senate Race Game

.pull-left[

- Apply backwards induction

1. What will .hi-brown[Brown] choose
  - If .hi-green[Green] were to .green[Enter]?
  - If .hi-green[Green] were to .green[Stay Out]?

]

.pull-right[
.center[
![](../images/pol_game_reverse.png)
]
]

---

# Mover Advantage: Senate Race Game

.pull-left[

- Apply backwards induction

1. What will .hi-brown[Brown] choose
  - If .green[Enter] then .brown[None]
  - If .green[Stay Out] then .brown[None]
  
- Note .brown[None] becomes a .hi-purple[dominant strategy] for .hi-brown[Brown]!

2. Given this, what will .green[Green] choose?
]

.pull-right[
.center[
![](../images/pol_game_reverse_2.png)
]
]

---

# Mover Advantage: Senate Race Game

.pull-left[

- .purple[Equilibrium:] (.green[Enter], .brown[(None, None)])
  - Payoffs of (.green[4], .brown[2])
  
- Recall original outcome (.brown[Ads], .green[(Stay Out, Enter)])
  - Payoffs of (.brown[3], .green[3])

- .hi-brown[Brown] is worse-off moving second vs. first; .hi-green[Green] is better off moving first vs. second
  - A .hi-purple[first-mover advantage] for either player
]

.pull-right[
.center[
![](../images/pol_game_reverse_rollback.png)
]
]

---

# When Order Matters

.pull-left[

- In general, to see if order matters, reverse sequence of moves and see if outcomes differ

- Games with first-mover advantage:
  - Century Mark
  - Tic-tac-toe
  - Chess? Checkers?

- Games with second-mover advantage:
  - Free riders
  - Business?
]

.pull-right[
.center[
![](../images/firstmove.jpg)
]
]

---

# When Order Matters

.left-column[
.center[
![:scale 80%](../images/claytonchristensen.jpg)

Clayton Christensen
]
]

.right-column[
.smallest[

&gt; “When you look across the sweep of business history, most companies that once seemed successful—the best practitioners of best practice—were in the middle of the pack (or, worse, the back of it) a decade or two later...What often causes this lagging behind are two principles of good management taught in business schools: that you should always listen to and respond to the needs of your best customers, and that you should focus investments on those innovations that promise the highest returns. But these two principles, in practice, actually sow the seeds of every successful company's ultimate demise,” (ix-x).

]

.source[Christensen, Clayton, 2016[1997], *The Innovator's Dilemma: When New Technologies Cause Great Firms to Fail*]
]

---

# When Order Matters

.left-column[
.center[
![:scale 80%](../images/petertheil.png)

Peter Thiel
]
]

.right-column[
.smallest[

&gt; “You've probably heard about 'first mover advantage': if you're the first entrant into a market, you can capture significant market share while competitors scramble to get started. But moving first is a tactic, not a goal...[B]eing the first mover doesn't do you any good if someone comes along and unseats you. It's much better to be the *last* mover—that is, to make the last great development in a specific market and enjoy years or even decades of monopoly profits.,” (57-58).

]

.source[Thiel, Peter, 2014, *Zero to One: Notes on Startups or How to Build the Future*]
]

---

class: inverse, center, middle

# Adding Players

---

# Adding Players

.center[
![:scale 65%](../images/3_player_game.png)
]

---

# Adding Players

.center[
![:scale 65%](../images/3_player_game_2.png)
]

---

# Adding Players

.center[
![:scale 65%](../images/3_player_game_3.png)
]

---

# Adding Players

.center[
![:scale 65%](../images/3_player_game_rollback.png)
]

--

.hi-purple[Equilibrium]: `\(\big\{\)`.pink[R], .blue[(D,U)], .purple[(B,B,A,A)] `\(\big\}\)`

---

# How About If We Change it to This

.center[
![:scale 45%](../images/game_hard.png)
]

---

# How About If We Change it to This

.center[
![:scale 45%](../images/game_hard_rollback.png)
]

.hi-purple[Equilibrium]: `\(\big\{\)`.pink[(R,X)], .blue[(U,D)], .purple[(B,B,B)] `\(\big\}\)`

---

# Summary

1. Construct a game tree
  - Place players in proper order
  - Specify which decisions are available to each player at each decision node
  - Specify payoffs to all players in terminal noides

--

2. Solve for rollback equilibrium
  - Start with last-mover, identify best response, prune all other branches
  - Work successively backwards to the root
  - Highlight equilibrium path of play
  - Equilibrium = set of (complete!) strategies all players are playing

---

class: inverse, center, middle

# How Reasonable is Rollback Thinking?

---

# How Reasonable is Rollback Thinking?

.pull-left[

- Useful for simple games with few players &amp; moves

- More difficult for complex games (more moves and/or players)
  - Tic-tac-toe has `\(9!\)` or `\(362,880\)` possible moves
]

.pull-right[
.center[
![](../images/tictactoe.png)

]
]

---

# How Reasonable is Rollback Thinking?

.pull-left[

- Chess estimated to have `\(10^{120}\)` possible moves

- Players need rules to assign “payoffs” to *non-terminal* nodes, an “intermediate value function”
  - Humans `\(&lt;\)` computers at anticipating future moves
  - Humans `\(&gt;\)` computers at mid-game intuition and experience
]

.pull-right[
.center[
![](../images/kasparovdeepblue.jpg)

.smallest[
Garry Kasparov vs. IBM's Deep Blue
]
]
]

---

# How Reasonable is Rollback Thinking?

.center[
&lt;iframe width="980" height="550" src="https://www.youtube.com/embed/aonCsvi0LKc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;
]

---

# How Reasonable is Rollback Thinking?

.center[
&lt;iframe width="980" height="550" src="https://www.youtube.com/embed/rspFsbq62yA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;

How Richard Hatch won the first Survivor]

---

# How Reasonable is Rollback Thinking?

.pull-left[
.center[
![](../images/survivorpolechallenge.jpg)
]
]

.pull-right[
.center[
![](../images/survivorgame.png)
]
]

---

class: inverse, center, middle

# Games on Moblab

---

# Split the Pie

.center[
![:scale 80%](../images/moblabdictator.png)
]

---

# The Dictator Game

.pull-left[
.center[
![](../images/dictatorgame.png)
]
]

.pull-right[
- Famously called .hi[“The Dictator Game”]
  - .hi-red[Player 1] is given money (e.g. $100) and decides how much of that `\((x)\)` to give to .hi-blue[Player 2]

- Used in experiments to measure altruism in societies

- What’s the .hi[rollback equilibrium]?

- What do we see in the real world?
]
---

# Split the Pie, Modified

.center[
![](../images/moblabultimatumproposer.png)
]

---

# Split the Pie, Modified

.center[
![](../images/moblabultimatumresponder.png)
]

---

# Ultimatum Game

.pull-left[
.center[
![:scale 80%](../images/ultimatumgame.png)
]
]

.pull-right[

- Equally famous game used in experiments, the .hi[Ultimatum game]
  - After .hi-red[Player 1] decides how much `\((x)\)` to give to .hi-blue[Player 2], .hi-blue[Player 2] can .blue[Accept] or .blue[Reject] (where nobody gets anything)

- What’s the .hi[rollback equilibrium]?

- What do we see in the real world?
]

---

# Pass the Pumpkin

.center[
![:scale 80%](../images/moblabcentipede.png)
]

---

# Pass the Pumpkin

.center[
![:scale 80%](../images/moblabcentipede2.png)
]

---

# Centipede Game

.pull-left[

.center[
![](../images/centipedegametree.png)
]
]

.pull-right[

- Called the .hi[Centipede game]
  - Players take turns deciding between **taking** money out of a pot vs. **passing**; after each **pass**, the money in the pot grows, until a set final turn

- What's the .hi[rollback equilibrium]?

- What do we see in the real world?
]

---

# Centipede Game

.center[
![](../images/Centipedepaper.png)
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script src="https://platform.twitter.com/widgets.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"slideNumberFormat": "<div class=\"progress-bar-container\">\n  <div class=\"progress-bar\" style=\"width: calc(%current% / %total% * 100%);\">\n  </div>\n</div>\n"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
